package guru.nicks.ratelimit;

import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebFilter;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.server.RequestPath;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;
import org.springframework.web.util.ServletRequestPathUtils;

import java.io.IOException;
import java.util.Optional;

/**
 * Applies rate limits to controllers methods annotated with {@link HttpRateLimit}.
 * <p>
 * WARNING: rate limiting doesn't work for multipart requests - see {@code HttpRequestImpl#parseFormData} method:
 * {@code readStarted} is true after {@link HttpServletRequest#getInputStream()}, which doesn't let read the parts.
 */
@ConditionalOnFeatureEnabledByDefault(ProjectFeature.RATE_LIMITS)
@WebFilter("Applies API rate limits to controller methods annotated with @HttpRateLimit (except multipart/form-data)")
@Component
@RequiredArgsConstructor
@Slf4j
public class HttpRateLimitFilter extends OncePerRequestFilter {

    // DI
    private final RateLimitService rateLimitService;
    private final ExceptionConverterService exceptionConverterService;
    private final ObjectMapper objectMapper;

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {
        // in HttpRequestImpl.parseFormData(), readStarted is always true after getInputStream(),
        // which doesn't let read the parts
        if (StringUtils.startsWithIgnoreCase(request.getHeader(HttpHeaders.CONTENT_TYPE), "multipart/")) {
            log.debug("Multipart requests cannot be rate-limited");
            filterChain.doFilter(request, response);
            return;
        }

        var cachedRequest = new MultipleTimesReadableHttpRequest(request);

        // copied from ServletRequestPathFilter, otherwise HandlerMapping bean (in RateLimitService) complains of
        // missing parsed request path
        @SuppressWarnings("java:S1941") // set variable earlier than it's formally needed (see reason above)
        RequestPath previousRequestPath = (RequestPath) request.getAttribute(ServletRequestPathUtils.PATH_ATTRIBUTE);
        ServletRequestPathUtils.parseAndCache(request);

        try {
            rateLimitService.limit(cachedRequest, response);
        } catch (Exception e) {
            BusinessExceptionDto errorDto = exceptionConverterService.createDto(e);
            log.error("Rendering {} because of {}", errorDto, ExceptionUtils.formatWithCompactStackTrace(e));
            response.setContentType(MediaType.APPLICATION_JSON_VALUE);

            response.setStatus(Optional.ofNullable(errorDto.getHttpStatus())
                    .orElse(HttpStatus.INTERNAL_SERVER_ERROR.value()));
            objectMapper.writeValue(response.getOutputStream(), errorDto);
            LogContext.RESPONSE_HTTP_STATUS.put(response.getStatus());
            return;
        }

        // pass cached request further, so its body can be read again as a stream
        try {
            filterChain.doFilter(cachedRequest, response);
        } finally {
            ServletRequestPathUtils.setParsedRequestPath(previousRequestPath, request);
        }
    }

    /**
     * Finds controller (or Actuator etc. - tries all handler mappings until one of them matches; this is what
     * DispatcherServlet does) which is designated to process request. To find a concrete method, pipe the result of
     * this method to {@link #findHandlerMethod(HandlerExecutionChain)}.
     *
     * @param request         request
     * @param handlerMappings handler mappings
     * @return optional request handler
     */
    private Optional<HandlerExecutionChain> findRequestHandlerChain(HttpServletRequest request,
            Collection<? extends HandlerMapping> handlerMappings) {
        return handlerMappings.stream()
                .map(handler -> {
                    try {
                        return handler.getHandler(request);
                    } catch (Exception e) {
                        log.warn("Can't find request handler chain: {}", ExceptionUtils.formatWithCompactStackTrace(e));
                        return null;
                    }
                }).filter(Objects::nonNull)
                .findFirst();
    }

    /**
     * Finds request handler method. There's no such method for {@code OPTIONS} method because it's
     * {@code org.springframework.web.servlet.handler.AbstractHandlerMapping.PreFlightHandler} (private class). For
     * static files, such as Swagger resources, it's {@link ResourceHttpRequestHandler} which isn't
     * {@link HandlerMethod} either.
     *
     * @param handler request handler chain, as returned by
     *                {@link #findRequestHandlerChain(HttpServletRequest, Collection)})
     * @return method inside controller (for emptiness, see explanation above)
     */
    private Optional<HandlerMethod> findHandlerMethod(HandlerExecutionChain handler) {
        // For OPTIONS method, the error is: java.lang.ClassCastException('class
        // org.springframework.web.servlet.handler.AbstractHandlerMapping$PreFlightHandler cannot be cast to class
        // org.springframework.web.method.HandlerMethod'). Similar for static files, such as Swagger resources.
        try {
            HandlerMethod handlerMethod = (HandlerMethod) handler.getHandler();
            return Optional.ofNullable(handlerMethod);
        } catch (ClassCastException e) {
            return Optional.empty();
        }
    }

}
